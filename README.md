# Практическая работа №11 "Сдача проекта Mesto: портирование и работа с API"

---

## Оглавление

1. Описание
2. Функциональность
3. Технологии, используемые в проекте
   - валидация форм;
   - открытие и закрытие pop up по клику мышкой, нажатию на кнопку "Esc", клику на фон;
   - редактиование и сохранение данных;
   - адаптивность сайта;
   - "резиновость" сайта;
   - флекc-элементы;
   - грид-элементы;
   - подключение шрифтов;
   - "отзывчивость" интерактивных элементов;
   - файловая структура проекта по правилам Nested БЭМ;
4. Ссылка на GitHub Pages

---

## 1. Описание

Данный проект - это одностраничный сайт, представляющий собой страничку на сервере с функциональностью и функциями, описанными ниже. Проект написан на реакте, так как код? написанный на данной библиотеке js, имеет следующие достоинства:

- экономится время на написании кода;
- контент загружается быстрее (особенно при плохом соединении и на медленных устройствах);
- улучшает ранжирование в поисковиках (поисковые боты будут видеть полностью отрендеренную страницу).

---

## 2. Функциональность

Данный сайт обладает следующими критериями функциональности:

- дизайн;
- контент;
- структура;
- доступные функции;

Под функциями понимаются следующие возможности:

- просмотра тектового материала без перехода на сторонние сайты;
- возможность изменения имени и места работы в сплывающем pop up;
- коректное внесение имени и "о себе", названия картинки и ссылки на нее в сплывающих pop up;
- возможность сохранения свои данных после ввода;
- возможность закрытия страницы без сохранения своих данных разными способами, описанными ранее.
- возможность добавления карточки в сплывающем pop up;
- возможность удаления карточки, а также постановки лайка карточке;
- возможность открытия картинки в большем масштабе в сплывающем pop up;

---

## 3. Технологии, используемые в проекте

В проекте были применены следующие технологии:

- подключение к серверу;
- сборка проекта. Webpack;
- применение классов;
- валидация форм;
- открытие и закрытие pop up по клику мышкой, нажатию на кнопку "Esc", клику на фон;
- редактиование и сохранение данных;
- Добавление карточки в сплывающем pop up;
- Удаление карточки;
- Постановка лайка карточке;
- Открытие картинки в большем масштабе в сплывающем pop up;
- адаптивность сайта;
- "резиновость" сайта;
- флекc-элементы;
- грид-элементы;
- подключение шрифтов;
- "отзывчивость" интерактивных элементов;
- файловая структура проекта по правилам Nested БЭМ;

### 3.1 Подключение к серверу

Данная технология реазилуется за счет следующих шагов:
3.1.1. Загрузка информации о пользователе с сервера
3.1.2. Загрузка карточек с сервера
3.1.3. Редактирование профиля
3.1.4. Добавление новой карточки
3.1.5. Отображение количества лайков карточки
3.1.6. Попап удаления карточки
3.1.7. Удаление карточки
3.1.8. Постановка и снятие лайка
3.1.9. Обновление аватара пользователя
3.1.10. Улучшенный UX всех форм

Данные технологии осуществлялись засчет получения/загрузки на сервер информации путем использования запроса с использованием индивидуального токена и названия когорты в классе Api. Ниже приведен пример загрузки информации о пользователе с сервера

```
Api.js:

getUserInfo() {
    return (
      fetch(`https://nomoreparties.co/v1/cohortId/users/me `, {
      method: "GET",
      headers: this._headers,
    })
        .then((res) => {
          if (res.ok) {
            return res.json();
          }
          //если запрос ушел, но пришел ответ с ошибкой
          return new Error("Что-то пошло не так"); //СОЗДАТЬ КЛАСС
        })
        //если запрос не ушел
        .catch((error) => {
          console.log(error);
        })
    );
  }
```

```
index.js:

api
.getUserInfo() //Получить мои данные
.then((user) => {
  userInfoElement.editProfile(user);
})

```

Все основные функции и изменения переменных реализуются в документе App, его дочерние компоненты содержат лишь функции, связанные с отправкой формы, и функции, пробрасывающие переменные в документ App. Единственная переменная, не пробрасываемая в основной документ, это _currentUser_. Ее использование происходит засчет подписки на контекст через провайдер в документе App.

```
App.js

import { CurrentUserContext } from "../contexts/CurrentUserContext.js";

export default function App() {

...

return (
<div className="app">
      <CurrentUserContext.Provider value={currentUser}>
        <div className="page">
          <Header />
          <Main... />
          <Footer />
          <EditProfilePopup ... />
          <EditAvatarPopup ... />
          <AddPlacePopup ... />
          <PopupWithForm ... />
          <ImagePopup ... />
        </div>
      </CurrentUserContext.Provider>
    </div>
)
}
```

#### 3.1.1. Загрузка информации о пользователе с сервера

Как уже говорилось ранее, информация о пользователе подгружается с сервера. Чтобы осуществить это, делался GET-запрос на URL с использованием индивидуального токена и названия когорты. Далее запрос вставлялся в основной js-файл.

#### 3.1.2. Загрузка карточек с сервера

Загрузка карточек с сервера осуществлялась через метод "PATCH" и имеет тело:

```
Api.js:

body: JSON.stringify({
        name: name,
        about: job,
      }),
```

#### 3.1.3. Редактирование профиля

Данная технология реализуется за счет запроса. В ответ на который пользователю приходит следующее:

```
{
  "name": "Marie Skłodowska Curie",
  "about": "Physicist and Chemist",
  "avatar": "https://pictures.s3.yandex.net/frontend-developer/common/ava.jpg",
  "_id": "e20537ed11237f86bbb20ccb",
  "cohort": "cohort-76",
}
```

#### 3.1.4. Добавление новой карточки

Данная технология реализуется за счет запроса, при положительном ответе которого новая карточка вставляется перед массивом из основных карточек с сервера.

```
App.js

function handleAddPlaceSubmit({ name, link }) {
    api
      .createNewCard({ name, link })
      .then((newCard) => {
        setCards([newCard, ...cards]);
        closeAllPopups();
      })
      .catch((error) => {
        //если запрос не ушел
        console.log(error);
      });
  }
```

#### 3.1.5. Отображение количества лайков карточки

Отображение количества лайков карточки реализуется за счет подсчета длинны массива лайкнувших пользователей карточку

```
{card.likes.length}
```

Переменная isLiked отвечает за проверку массива всех лайкнувших карточку на наличия в нем id текущего пользователя.

```
const isLiked = card.likes.some((i) => i._id === currentUser._id);
```

Если id текущего пользователя найден, то добавляется класс "active", и лайк ставится.

```
const cardLikeButtonClassName = `element__image-like ${
    isLiked && "element__image-like_active"
  }`;
```

#### 3.1.6. Попап удаления карточки

Создается попап удаления карточки, который всплывает при клике на значок урны. Данная технология реализуется через запрос, при положительном ответе которого всплывает попап удаления, путем добавления к нему класса _opened_.

#### 3.1.7. Удаление карточки

При нажатии в попапе удаления кнопки "Да", массив карточек, пришедший с сервера, изменяется и в нем уже отсутствует карточка, значок урны которой был нажат.

#### 3.1.8. Постановка и снятие лайка

См. п.3.1.5. Отображение количества лайков карточки

#### 3.1.9. Обновление аватара пользователя

Данная технология реализуется за счет всплытия попапа с импутом и кнопкой, при заполнении поля и нажатии кнопки вставляется на страницу и сервер новая картинка также через определенный запрос в документе Api. Состояние переменной _setCurrentUser_ меняется на _(user)_, который пришел с сервера.

#### 3.1.10. Улучшенный UX всех форм

Улучшение UX всех форм осуществляется за счет оповещения пользователе об этапах загрузки/сохранения его и(или) карточки, и(или) аватара, и(или) данных.

### 3.2 Сборка проекта. Webpack

Данная технология реализована путем использования модулей при разработке, а перед загрузкой проекта в интернет происходит сбор всех получившихся файлов в один и подключение в HTML. В процессе такой сборки код преобразуется: сжимается и работает в старых браузерах. Все это делается автоматически при сборке проэкта, благодаря реакту и быстрому старту из-за установки пакета _npx create-react-app my-app_ в программе Windows PoverShell.
Сборка проекта происходит через коммандную строку Node.js путем скачивания необходимых материалов и написания скриптов с последующим их вызовом. Также создаются файлы с типом JSON и js, в которых прописывается, "куда заглянуть" программе, куда положить собранные файлы, и что делать с файлами разных типов.

### 3.3 Применение классов

В файле App.js, в котором осуществляются вызовы функций, создаются экземпляры компонентов посредством новых констант и импорта функций в указанный документ.

### 3.4 Валидация форм

Данная технология реализуется посредством кода из js документа. Технология представляет собой несколько этапов, содержащих по одной функции на каждое действие. Вкратце это будет звучать так:

1. При открытии любого из попапов кнопка сохраниения данных/добавления карточки неактивна.
2. При изменении данных профиля/карточки проверяется количество введенных символов(у каждого input свой интервал значений). Также проверяется является ли введенные символы в поле, где должна быть ссылка, сылкой.
3. При соответствии всех инпутов данным требованиям в каждой рассматриваемой форме кнопка сохранения/добавления становится активной.

### 3.5 Открытие и закрытие pop up по клику мышкой, нажатию на кнопку "Esc", клику на фон

Данная технология реализуется посредством кода из js документа. Ниже представлен пример открытия pop up. Технология представляет собой объявление и присвоение переменной, описание и вызов функции.

```
jS:

//константа равна открытому попапу
const isSomePopupOpen =
    isEditProfilePopupOpen ||
    isAddPlacePopupOpen ||
    isEditAvatarPopupOpen ||
    selectedCard;

//закрытие на темный фон
  const handleOverlayClose = React.useCallback((event) => {
    if (event.target.classList.contains("popup")) {
      /*закрытие всех попапов*/
      ...
    }
  }, []);

  //закрытие на esc
  const handleCloseByEsc = React.useCallback((event) => {
    if (event.key === "Escape") {
      /*закрытие всех попапов*/
      ...
    }
  }, []);

React.useEffect(() => {
    if (isSomePopupOpen) {
      document.addEventListener("keydown", handleCloseByEsc);
      document.addEventListener("click", handleOverlayClose);
      return () => {
        document.removeEventListener("keydown", handleCloseByEsc);
        document.removeEventListener("click", handleOverlayClose);
      };
    }
  }, [isSomePopupOpen]);

```

Обязательно снимае обработчики после их применения(закрытия попапа), так как нет смысла пользоваться обработчиками закрытия попапа при и так уже закрытом попапе.

### 3.6 Редактиование и сохранение данных

Данные технологии реализуется по аналогии с технологиями выше: делается запрос и при положительном его ответе именяется переменная состояния на то, что пришло с сервера/отправляется на сервер и меняется значение в разметке.

### 3.7 Добавление карточки в сплывающем pop up

См. п.3.1.4. Добавление новой карточки

### 3.8 Удаление карточки

См. п.3.1.6. Попап удаления карточки и п.3.1.7 Удаление карточки

### 3.9 Постановка лайка карточке

См. п.3.1.5. Отображение количества лайков карточки

### 3.10 Открытие картинки в большем масштабе в сплывающем pop up

Данная технология реализуется посредством кода из js документа. Ниже представлен пример открытия картинки в большем масштабе. Данная часть кода вставляется в App.js с последующей вставкой в основную разметку. При клике на картинку карточке, через пропс card в попапе в значениях ссылки на картинку и имени карточки спрашивается _card ?_ и при положительном ответе вставляется _card.name_ и _card.link_ в соответствующую разметку. _Card_ пробрасывается через пропс в App.js, где его значение меняется через переменную состояния при клике в документе Main.

### 3.11 Адаптивность сайта

Для адаптивности сайта используются медиазапросы на разные брейкпоинты. Эта технология позволяет сделать сайт доступных для устройств с различными разрешеиями.

```
CSS:

@media screen and (max-width=320px) {
  header: {
    margin-top: 6px;
  }
}
```

### 3.12 "Резиновость" сайта

Данная технология позволяет сделать сайт для комфортного просмотра между брекпоинтами с помощью изменения размеров элементов при изменении разрешения экрана.

```
CSS:
  header: {
    max-width: 320px;
    width: 100%;
  }

```

### 3.13 Флекс-элементы

Данная технология помогает изменять размеры элементов при изменении масштаба и помогает сделать сайт более "резиновым"

### 3.14 Грид-элементы

Данная технология помогает изменять размеры элементов при изменении масштаба, облегчает расположение элементов по сетке (секция elements) и помогает сделать сайт более "резиновым"

### 3.15 Подключение шрифтов;

```
@font-face {
  font-family: "Inter";
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(./Inter/Inter-Regular.woff2) format("woff2"),
    url(./Inter/Inter-Regular.woff) format("woff");
}
```

### 3.16 "Отзывчивость" интерактивных элементов

Данная технология реализуется за счет добавления интерактивным элементам (кнопкам) css-свойства

```
opacity: 0.6;
```

или

```
opacity: 0.6;
```

### 3.17 Файловая структура проекта по правилам Nested БЭМ

```
папка "блок"
    папка "__элемент"
        папка "_ключ модификатора"
            папка "_значение модификатора"
                файл  "блок__элемент_значение модификатора"
    файл "блок__элемент.css"
файл "блок.css"
```

## 4. Ссылка на GitHub Pages

https://milenairon.github.io/mesto-react/
